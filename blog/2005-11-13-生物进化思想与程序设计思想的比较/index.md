---
title: "生物进化与软件演化"
date: "2005-11-13"
tags: 
  - "天马行空"
  - "码农札记"
---

作为一名软件工程师，同时拥有生物医学的研究背景，我对计算机科学与生物学都有着浓厚的兴趣。平日里，这两方面的书籍常常是我的读物。虽然这两门学科看似风马牛不相及，但它们的某些思想却能够相互借鉴、启发。这篇文章将分享进化论的相关理论如何影响了我的程序设计思路，以及在学习编程思想后对进化论的新认识。

## 一、基因突变与物竞天择思想在编程算法中的应用

计算机科学中有一门学科叫做遗传算法，它系统地探讨了如何将遗传与进化的思想引入计算机科学，比我的尝试要深入得多。不过，在正式接触这门学科之前，我曾经有过一些朴素的探索。

最初接触这个问题的契机是这样的：一个朋友刚学会了黑白棋（Othello），邀请我对战。虽然他是个新手，但我的水平更糟糕，总是输给他。于是我萌生了一个想法：既然下棋不行，那不如发挥编程的专长，写个程序来击败他。然而，问题在于我对黑白棋的规则和策略了解有限，怎么确保程序能比我更强呢？

黑白棋规则相对简单，基本算法容易实现。我最初的想法是让计算机模仿我的思路下棋，借助它的计算速度优势，理论上应该能比我强一些。但这还不够，我希望程序能通过某种方式自我学习、不断提升棋艺。这个想法受到了进化论中基因突变和物竞天择思想的启发：让不同的程序进行对战，淘汰表现差的，保留和优化表现好的，从而推动棋力的逐代提高。

我的方法是提取可能影响棋局胜负的参数，比如棋子的落点、每颗棋子周围的空格数量、己方可落子的数量、对方可落子的数量等等。虽然我对这些参数的实际作用心中无数，但参数一定要“宁多勿漏”，程序会自动筛选出那些有用的参数。这些参数可以看作程序的“基因”，不同程序的区别就在于这些参数的具体值有所不同。

接下来，我组织了几十个程序进行循环赛，并将成绩居于后半的程序淘汰；成绩靠前的程序保留它们的“基因”，还可以通过“基因重组”和“随机突变”等方式，调整参数的值，生成新的后代。如此一代代模拟进化，程序的棋力也随之逐步提高。

最终，这个程序经过一段时间的自我训练，成功战胜了我的朋友。这让我感到相当自豪！ [](images/smile_teeth.gif)。

然而，这种“进化式”程序设计也暴露了一些明显的问题，最主要的是效率低下。程序棋力的提升非常缓慢。这点其实不难理解，毕竟生物界花了数十亿年的时间才进化到今天的水平。即便我的程序效率远高于自然进化，想取得显著的进步也可能需要数百年的时间。

另外，每代程序的“种群规模”太小，仅有几十个样本。相比之下，生物界每代往往有几百万甚至几亿的个体，这样的大样本量才能提供足够的多样性。我的程序等于在“近亲繁殖”，甚至可能导致棋力一代不如一代。这两个问题的根源在于计算机的运算与存储能力有限。

遗传算法中提到的解决方案远比我的方法成熟，但也存在类似的局限性。对这一领域感兴趣的读者不妨深入研究相关书籍。

## 二、对进化论的反思

假如我基于基因突变和物竞天择思想设计的黑白棋程序，一直按照既定规则运行，经过几万年的演化，是否可能进化成能够下五子棋或者其他棋类的程序呢？这一问题引发了我对进化论的重新思考。

达尔文在《物种起源》中提出了两大核心假设：同源说和进化论。同源说认为地球上的所有物种都源于同一个最初的生命体，这一观点得到了较为广泛的认可，特别是在基因学和分子生物学的支持下。比如，人类与单细胞细菌之间也存在高度同源的基因，这为同源说提供了强有力的佐证。

然而，进化论，即通过基因突变和物竞天择解释物种多样性的假说，却从一开始便饱受质疑。虽然 DNA 的发现为进化论提供了一定支持，但仅凭基因突变与自然选择能否完全解释生物的演化仍存在诸多争议。

进化论主要依赖三大证据：比较解剖学、古生物学（化石记录）以及胚胎发育的重演律。然而，这些证据并非无懈可击。

1. 比较解剖学
人类和猴子的骨骼结构高度相似，这是比较解剖学的经典证据之一。有人认为这是一种循环论证：人和猴子的骨骼相似是因为它们有共同的祖先，而为何有共同祖先的原因又归结于骨骼的相似性。然而，我认为骨骼相似本身是一种客观现象，无需证明，也无需与进化论挂钩。这一现象可以很好地支持同源说，但却无法解释生物演变的具体过程。

2. 古生物学（化石记录）
按照基因突变理论，生物的演化应是一个缓慢而连续的过程。然而，化石记录却提供了截然不同的图景。大多数化石展示的是物种突然出现并长期保持稳定的状态，过渡类型的化石寥寥无几。例如，始祖鸟是为数不多的“过渡类型”化石之一，但与成千上万的物种化石相比，显得过于稀少。

更为显著的是所谓的“寒武纪大爆发”现象：在30亿年前至5亿年前的漫长时间里，化石记录几乎全部是单细胞生物。然而在5亿年前，各种复杂的多细胞生物似乎在一夜之间出现在海洋中。这种突发性和缺乏过渡类型的化石记录，更多地揭示了基因突变理论的局限性。

3. 胚胎发育的重演律
重演律认为胚胎发育过程会重现物种的演化历程。然而，如果进化的驱动力是基因突变，原有的信息理应被替代或遗忘，那么胚胎为何会保留并重现这些信息？除非生物的演化并非完全依赖基因突变，而可能涉及更为复杂的机制。

回到文章开头的问题：如果让我的黑白棋程序持续进行基因变化，它能否演化为下五子棋或其他棋类的程序？答案显然是否定的。因为黑白棋程序的基因设定是专注于黑白棋规则的，在没有外界干预或新信息输入的情况下，它的“进化”只会局限在原有的范围内。这表明，“基因突变”并不足以解释复杂系统如何从无到有地发展出新的功能。

综合来看，进化论的三大证据在解释物种多样性时都存在局限性。尽管基因突变和自然选择无疑在演化中起到了重要作用，但将其作为唯一机制，可能无法全面揭示生物演化的真实过程。或许，探索其他未被完全理解的生物机制，才是进一步解答这些谜题的关键。

## 三、程序是如何“进化”的

虽然我的黑白棋程序无法自行进化成五子棋程序，但在我的干预下，这种“进化”却完全可行。

我的程序使用 C++ 编写。熟悉 C++ 的人都知道，即使是一个简单的程序，也通常会运用面向对象和泛型编程等思想，我自然也不例外。那么，如果我打算开发一个五子棋程序，应该如何着手呢？

黑白棋和五子棋有许多相似之处，比如棋盘的类型、棋子的基本属性等。如果从头重新创建一个五子棋程序，显然既费时又低效。

最直接的办法是复制原来的黑白棋代码，然后在此基础上修改。然而，这种方法存在明显的问题：代码冗余。两份程序会包含大量重复代码，不仅浪费资源，还会给后续的维护带来麻烦。比如，如果我优化了黑白棋程序的某部分代码，还需要手动将改进同步到五子棋程序中，这显然不够灵活。

得益于面向对象的编程方法，这个问题可以迎刃而解。我可以将黑白棋程序中的核心功能抽象为一个基类，并在此基础上派生出五子棋的类。五子棋中与黑白棋不同的特性和方法，可以通过覆写（override）实现。在这种设计下，基类的代码仍然存在，但被覆写的部分在五子棋类中将被替代或补充。

更有趣的是，某些基类的功能并不会因为派生类的覆写而完全消失。例如，子类的构造函数通常会先调用基类的构造函数，然后再执行自己的逻辑。这意味着，父类的一些特征和行为仍然能够保留，并在子类实例化的过程中显现出来。

这种基类与派生类的关系，很容易让人联想到胚胎发育的重演过程。在生物学中，胚胎在发育早期会呈现出某些祖先的特征，而随着发育的进行，这些特征逐渐被新的结构和功能取代。这与程序设计中基类的部分代码被派生类覆盖，却依然能够影响派生类的实例化过程有异曲同工之妙。

这种程序设计方式，不仅减少了代码的重复性，还保留了灵活扩展的可能性。就像生物演化中的“保守与创新并存”，程序设计也在继承已有功能的基础上不断发展出新的特性。

## 四、对生物的进化的反思

参考程序自动“进化”的规律，我们或许可以提出一种新的假设：基因突变仅能在同一物种的小范围内引起改良，而真正导致质的变化的，除了量的积累外，更多的可能是类似程序中“继承”或“重组”这样的基因操作。

现代生物学研究发现，高等生物的染色体中存在大量所谓的“无用”基因片段。这些片段虽然在当前看似不起作用，但它们可能在生物的进化历史中曾经扮演过重要角色。随着生物体获得新的基因片段，这些新片段可能具有与旧片段类似的功能，但表现出更高的优先级，从而抑制了旧片段的活性。

当新基因片段主导生物体的功能后，旧片段逐渐失去作用，成为看似“无用”的遗留。然而，这些片段并未被完全淘汰，它们的存在暗示着一种“历史记忆”，记录了生物在进化过程中经历的不同阶段。这一机制与软件开发中的代码继承有异曲同工之妙：旧的功能被保留但不再被调用，而新的功能覆盖了它们的位置。

那么新基因片段是从何而来的呢？有很多种可能性，比如：
- 有性繁殖的重组：有性繁殖是基因多样性的重要来源。在此过程中，父母的染色体通过交叉和重组，形成了包含新组合的染色体。而在某些特殊情况下，可能会引入完全新颖的基因片段，从而为后代带来前所未有的功能。
- 基因交换：在低等生物中，比如细菌，基因交换是一种常见现象。通过质粒转移或其他方式，细菌可以将自身的基因传递给其他个体，这种机制为基因创新提供了直接途径。
- 病毒的作用：病毒能够将自己的基因插入宿主细胞的染色体中。在某些情况下，这些外来基因可能被宿主整合并表达，从而引入新的遗传信息。
- 外部环境的输入：新基因片段可能通过饮食或环境途径间接进入生物体。例如，食物中的 DNA 在极特殊的情况下可能被吸收并整合进自身的基因组中。

从以上分析可以看出，生物进化并非完全依赖基因突变的随机性，而是一个更为复杂的过程。突变提供了变异的基础，但快速的进化可能更依赖于基因重组、新基因的引入，以及生物间的遗传信息共享。

这种进化机制与软件设计中的继承和扩展有相似之处：旧有的功能可以被继承和改良，新功能的引入则通过扩展实现。这种“保守与创新”的平衡，或许正是生物进化与程序设计的共同规律。

## 五、未来软件的发展趋势

生物用了 30 亿年的进化才发展到今天的复杂程度，而计算机软件仅仅发展了不到50年。尽管两者当前的复杂性尚无法直接比较，但在人类智慧的推动下，软件进化的速度可能远超生物进化。或许在未来百年内，我们就能看到具备自我完善能力的智能软件，其发展速度可能是生物进化的千万倍。基于这一思路，我们可以大胆预测，未来软件的发展也许会在某些方面与生物进化展现出类似的规律。

在维护大型软件时，处理遗留代码（legacy code）是一个常见的挑战。例如，我最近需要修改一段存在于公司大型软件中的老旧代码。这些代码风格极差，如变量名使用单字符表示、大量硬编码等。如果几年前的我，可能会直接选择彻底重写这段代码。然而，实践经验表明，这种做法往往得不偿失。

一个大型软件经过几十年的发展，可能有数百甚至上千人参与过开发，其代码之间交织着复杂的引用关系。贸然重写某段代码，极可能在功能上无法完全覆盖原有逻辑，进而引入更多的隐性bug。而这正如生物学中所谓的“无用基因片段”：它们表面上似乎没有功能，但实际上可能隐藏着潜在的价值或作用。

现在生物学上，研究基因片段功能的方法主要是，先把一段基因敲掉，然后看看他对生物体带来了什么影响。然而大多数基因被敲掉以后，却看不出生物体受到了明显的影响，这就是那些“无用”基因片断。这一是因为上面提到的基因有备份，备用基因会及时发挥作用，弥补缺失的基因的功能。还有就是很多基因的功能是和其他很多基因共同作用才能显现出来的，或者是在某些特殊情况下才会被显现出来的。这些基因的功能不是那么容易被观察到的，他们缺失了，或者被添加到一个本来不具备这种基因的生物体上，它们的潜在的影响或许要过很多年才能被发现。现在大家对转基因作物的戒心，这也是原因之一。（对转基因食物更大的担心可能是在于，被植入的基因片段不够稳定，更容易整合到人体基因中去，导致人类的基因被转化。）

对遗留代码的最佳处理方式，通常不是直接改写，而是通过添加包装层的方式进行优化。例如：

- 如果原代码是一个简单的除法运算，没有处理除数为零的情况，最佳做法不是直接修改源代码，而是在其外部包裹一层新函数。新函数负责检查除数是否为零，若是，则进行错误处理；否则调用原代码执行除法。这种方法避免了对原代码行为的直接改动，同时确保新的功能可控且安全。
- 如果需要改动的是一个类，则可以通过继承原有类，创建一个派生类。在新类中覆盖或添加所需的功能，而原有类保持不变。这样，旧代码的稳定性得以保留，而新功能通过扩展实现。

这一策略的缺点在于：会导致程序体积迅速膨胀。然而，随着存储成本的下降和计算机硬件能力的提升，程序体积不再是首要问题。维护效率和功能安全性将成为更重要的考量。

随着软件系统的规模日益庞大，完全消除bug几乎是不可能的。尤其在关键场景中，系统的任何故障都会带来不可接受的损失。在这种情况下，备份机制成为保障系统稳定性的最佳手段。硬件系统已经普遍采用备份策略，未来的软件系统也会逐步引入这一思路。例如，对于某些核心功能，软件可以采用双实现策略：由不同的开发团队设计两套独立的实现代码。在正常情况下使用其中一套，当出现异常时自动切换到备份代码。这一方法与生物基因的双拷贝特性非常相似。生物体内的基因通常成对存在，不仅是为了繁衍后代，更是为了在突变或损伤时提供冗余保障。例如，当一条基因出现缺陷时，另一条可以迅速接替其功能，确保生物体正常运作。

随着技术的持续发展，软件的进化将越来越表现出类似生物系统的特性：
- 冗余与容错：通过多版本实现和模块化设计，软件将具备更高的容错能力。
- 继承与扩展：老旧代码不会被轻易抛弃，而是在其基础上进行扩展和优化，形成可持续的演进路径。
- 自我完善：在人工智能的帮助下，未来的软件可能具备自我优化和自我修复能力，实现从“人类驱动”到“自我驱动”的飞跃。
- 
生物进化依赖基因的突变与重组，而软件进化则依靠人类的智慧和创新。当我们结合生物与软件的进化规律进行思考，也许会发现，两者最终的目标并不冲突：创造出更智能、更高效的系统，推动未来社会的发展。
