---
title: "生物进化思想与程序设计思想的比较"
date: "2005-11-13"
tags: 
  - "浮生若梦"
  - "码农札记"
---

作为一名软件工程师，同时拥有生物医学的研究背景，我对计算机科学与生物学都有着浓厚的兴趣。平日里，这两方面的书籍常常是我的读物。虽然这两门学科看似风马牛不相及，但它们的某些思想却能够相互借鉴、启发。这篇文章将分享进化论的相关理论如何影响了我的程序设计思路，以及在学习编程思想后对进化论的新认识。

## 一、基因突变与物竞天择思想在编程算法中的应用

计算机科学中有一门学科叫做遗传算法，它系统地探讨了如何将遗传与进化的思想引入计算机科学，比我的尝试要深入得多。不过，在正式接触这门学科之前，我曾经有过一些朴素的探索。

最初接触这个问题的契机是这样的：一个朋友刚学会了黑白棋（Othello），邀请我对战。虽然他是个新手，但我的水平更糟糕，总是输给他。于是我萌生了一个想法：既然下棋不行，那不如发挥编程的专长，写个程序来击败他。然而，问题在于我对黑白棋的规则和策略了解有限，怎么确保程序能比我更强呢？

黑白棋规则相对简单，基本算法容易实现。我最初的想法是让计算机模仿我的思路下棋，借助它的计算速度优势，理论上应该能比我强一些。但这还不够，我希望程序能通过某种方式自我学习、不断提升棋艺。这个想法受到了进化论中基因突变和物竞天择思想的启发：让不同的程序进行对战，淘汰表现差的，保留和优化表现好的，从而推动棋力的逐代提高。

我的方法是提取可能影响棋局胜负的参数，比如棋子的落点、每颗棋子周围的空格数量、己方可落子的数量、对方可落子的数量等等。虽然我对这些参数的实际作用心中无数，但参数一定要“宁多勿漏”，程序会自动筛选出那些有用的参数。这些参数可以看作程序的“基因”，不同程序的区别就在于这些参数的具体值有所不同。

接下来，我组织了几十个程序进行循环赛，并将成绩居于后半的程序淘汰；成绩靠前的程序保留它们的“基因”，还可以通过“基因重组”和“随机突变”等方式，调整参数的值，生成新的后代。如此一代代模拟进化，程序的棋力也随之逐步提高。

最终，这个程序经过一段时间的自我训练，成功战胜了我的朋友。这让我感到相当自豪！ [](images/smile_teeth.gif)。

然而，这种“进化式”程序设计也暴露了一些明显的问题，最主要的是效率低下。程序棋力的提升非常缓慢。这点其实不难理解，毕竟生物界花了数十亿年的时间才进化到今天的水平。即便我的程序效率远高于自然进化，想取得显著的进步也可能需要数百年的时间。

另外，每代程序的“种群规模”太小，仅有几十个样本。相比之下，生物界每代往往有几百万甚至几亿的个体，这样的大样本量才能提供足够的多样性。我的程序等于在“近亲繁殖”，甚至可能导致棋力一代不如一代。这两个问题的根源在于计算机的运算与存储能力有限。

遗传算法中提到的解决方案远比我的方法成熟，但也存在类似的局限性。对这一领域感兴趣的读者不妨深入研究相关书籍。

## 二、对进化论的反思

假如我基于基因突变和物竞天择思想设计的黑白棋程序，一直按照既定规则运行，经过几万年的演化，是否可能进化成能够下五子棋或者其他棋类的程序呢？这一问题引发了我对进化论的重新思考。

达尔文在《物种起源》中提出了两大核心假设：同源说和进化论。同源说认为地球上的所有物种都源于同一个最初的生命体，这一观点得到了较为广泛的认可，特别是在基因学和分子生物学的支持下。比如，人类与单细胞细菌之间也存在高度同源的基因，这为同源说提供了强有力的佐证。

然而，进化论，即通过基因突变和物竞天择解释物种多样性的假说，却从一开始便饱受质疑。虽然 DNA 的发现为进化论提供了一定支持，但仅凭基因突变与自然选择能否完全解释生物的演化仍存在诸多争议。

进化论主要依赖三大证据：比较解剖学、古生物学（化石记录）以及胚胎发育的重演律。然而，这些证据并非无懈可击。

1. 比较解剖学
人类和猴子的骨骼结构高度相似，这是比较解剖学的经典证据之一。有人认为这是一种循环论证：人和猴子的骨骼相似是因为它们有共同的祖先，而为何有共同祖先的原因又归结于骨骼的相似性。然而，我认为骨骼相似本身是一种客观现象，无需证明，也无需与进化论挂钩。这一现象可以很好地支持同源说，但却无法解释生物演变的具体过程。

2. 古生物学（化石记录）
按照基因突变理论，生物的演化应是一个缓慢而连续的过程。然而，化石记录却提供了截然不同的图景。大多数化石展示的是物种突然出现并长期保持稳定的状态，过渡类型的化石寥寥无几。例如，始祖鸟是为数不多的“过渡类型”化石之一，但与成千上万的物种化石相比，显得过于稀少。

更为显著的是所谓的“寒武纪大爆发”现象：在30亿年前至5亿年前的漫长时间里，化石记录几乎全部是单细胞生物。然而在5亿年前，各种复杂的多细胞生物似乎在一夜之间出现在海洋中。这种突发性和缺乏过渡类型的化石记录，更多地揭示了基因突变理论的局限性。

3. 胚胎发育的重演律
重演律认为胚胎发育过程会重现物种的演化历程。然而，如果进化的驱动力是基因突变，原有的信息理应被替代或遗忘，那么胚胎为何会保留并重现这些信息？除非生物的演化并非完全依赖基因突变，而可能涉及更为复杂的机制。

回到文章开头的问题：如果让我的黑白棋程序持续进行基因变化，它能否演化为下五子棋或其他棋类的程序？答案显然是否定的。因为黑白棋程序的基因设定是专注于黑白棋规则的，在没有外界干预或新信息输入的情况下，它的“进化”只会局限在原有的范围内。这表明，“基因突变”并不足以解释复杂系统如何从无到有地发展出新的功能。

综合来看，进化论的三大证据在解释物种多样性时都存在局限性。尽管基因突变和自然选择无疑在演化中起到了重要作用，但将其作为唯一机制，可能无法全面揭示生物演化的真实过程。或许，探索其他未被完全理解的生物机制，才是进一步解答这些谜题的关键。

## 三、程序是如何“进化”的

虽然我的黑白棋程序无法自行进化成五子棋程序，但在我的干预下，这种“进化”却完全可行。

我的程序使用 C++ 编写。熟悉 C++ 的人都知道，即使是一个简单的程序，也通常会运用面向对象和泛型编程等思想，我自然也不例外。那么，如果我打算开发一个五子棋程序，应该如何着手呢？

黑白棋和五子棋有许多相似之处，比如棋盘的类型、棋子的基本属性等。如果从头重新创建一个五子棋程序，显然既费时又低效。

最直接的办法是复制原来的黑白棋代码，然后在此基础上修改。然而，这种方法存在明显的问题：代码冗余。两份程序会包含大量重复代码，不仅浪费资源，还会给后续的维护带来麻烦。比如，如果我优化了黑白棋程序的某部分代码，还需要手动将改进同步到五子棋程序中，这显然不够灵活。

得益于面向对象的编程方法，这个问题可以迎刃而解。我可以将黑白棋程序中的核心功能抽象为一个基类，并在此基础上派生出五子棋的类。五子棋中与黑白棋不同的特性和方法，可以通过覆写（override）实现。在这种设计下，基类的代码仍然存在，但被覆写的部分在五子棋类中将被替代或补充。

更有趣的是，某些基类的功能并不会因为派生类的覆写而完全消失。例如，子类的构造函数通常会先调用基类的构造函数，然后再执行自己的逻辑。这意味着，父类的一些特征和行为仍然能够保留，并在子类实例化的过程中显现出来。

这种基类与派生类的关系，很容易让人联想到胚胎发育的重演过程。在生物学中，胚胎在发育早期会呈现出某些祖先的特征，而随着发育的进行，这些特征逐渐被新的结构和功能取代。这与程序设计中基类的部分代码被派生类覆盖，却依然能够影响派生类的实例化过程有异曲同工之妙。

这种程序设计方式，不仅减少了代码的重复性，还保留了灵活扩展的可能性。就像生物演化中的“保守与创新并存”，程序设计也在继承已有功能的基础上不断发展出新的特性。

## 四、对生物的进化的反思

参考软件自动进化的规律，也许有这种可能：简单的基因突变只会导致同一物种的小变化范围内的改良。而能够导致物种变化的主要是基因上类似“继承”的操作。

按照现在的研究成果，高等生物体的染色体都存在有大量的“无用”基因片断。这些基因片断在生物进化的历史上或许并不是无用的，他们曾经是对这种生物发育起到作用的。但是，随着新的基因片断被加入到该生物体内，某些新基因片断可能与旧有基因片断存在着类似的功能，但优先级更高，抑制了原来基因片断的活性。之后，生物体所体现出来的行为就都是由新的基因片断决定的，原有的片段就成了无用片断了。

至于新片断是哪来的，我想首先可能来自于有性繁殖。有性繁殖除了把父母的两条染色体合成一对，有时也许还会带入全新的基因片断。其次，低等生物，比如细菌，个体间会有基因交换行为。新片断也可能来自于病毒的传播，或者通过饮食等途径带进来了。

## 五、未来软件的发展趋势

生物进化了30亿年，才达到现在的程度。计算机软件出现了不过50年。这两者目前似乎没有太多的可比性，但是我想在人类智慧的帮助下，软件的进化速度会大大高于生物的进化速度。出现拥有智慧的，可以自我完善软件也许只需几百年，是生物进化速度的 10,000,000 倍。我们不妨大胆预测一下未来软件的发展趋势。软件未来的发展也一定会与生物进化有某些类似的地方。

最近我开始着手更新一部分程序代码。这部分代码存在于公司一个非常大型的应用软件中，我需要修改的这段代码已经有很多年的历史了。其风格，按现在的观点来看，是非常差的。比如说变量名都是用单个字符表示的、存在大量硬编码等等。如果是年轻几岁的我，看到这段代码会认为根本没有维护它的必要，就应该把他们彻底抛弃，重写一遍。事实上，公司里确实有人曾经试图这样做过：刚看到很原始的代码，对他嗤之以鼻，又对自己的能力充满自信，于是开始对部分代码重写。但最终，这些尝试都以失败告终。

在一个有些历史大型软件中，遗留着着几十年前的代码是很正常的。这些代码不是不可以被改写，但是如果综合考虑代价和收益，可能改写他们是非常不合算的。一个大型的软件，经过几十年，被成百上千的人改动过，它当中相当一部分代码都会被软件中其它的地方引用到。到最后，没人能够说得清楚这段代码全部用途了。如果只做了少部分验证，就贸然把这段代码重写，新写的代码在功能上很难保持与原代码完全一致。将来会慢慢发现，新代码引入的bug和潜在危险远比它带来的好处大。

现在生物学上，研究基因片段功能的方法主要是，先把一段基因敲掉，然后看看他对生物体带来了什么影响。然而大多数基因被敲掉以后，却看不出生物体受到了明显的影响，这就是那些“无用”基因片断。这一是因为上面提到的基因有备份，备用基因会及时发挥作用，弥补缺失的基因的功能。还有就是很多基因的功能是和其他很多基因共同作用才能显现出来的，或者是在某些特殊情况下才会被显现出来的。这些基因的功能不是那么容易被观察到的，他们缺失了，或者被添加到一个本来不具备这种基因的生物体上，它们的潜在的影响或许要过很多年才能被发现。现在大家对转基因作物的戒心，这也是原因之一。（对转基因食物更大的担心可能是在于，被植入的基因片段不够稳定，更容易整合到人体基因中去，导致人类的基因被转化。）

那么针对这样一段老的代码，需要修改其bug，或是增强某些功能，最好的办法不是重写它，而是把它原封不动的留着，在它的上层再写一层外壳。在这层包装层内对源代码的功能加以修正。以后再用到这段代码的功能时，调用包装层提供的函数。

比如说源代码是个除法运算，但是没考虑除零的特殊情况，我们不是去改动源代码来判断参数是否为零，而是为它包一层新的函数。在新函数中先检查除数是否为零，如果是，进行错误处理；否则调用原代码进行除法运算。新的程序再用到除法功能就试用新写的函数。这样做的好处是：原本那个除法可能被用在了系统中的很多地方，或许某个地方就是要利用它的除零错误。你不能百分之百确定没有这种情况的出现，就贸然改变这个函数的行为。结果在系统的其它部位又引起了新的bug。这个新的bug更危险，因为你还没有意识到它的存在。

如果要改进的是个类，那么就在原来类的基础上派生出一个新的类。在新类里覆盖或添加一些功能。原有的类也是保持不变。

这种做法是有明显缺点的，就是空间效率太差。用这种方法维护的程序，体积会飞速膨胀。但是随着科技的发展，计算机存储设备开销，相对于软件维护来说会越来越便宜。迟早有一天，软件的大小将不再是一个需要考虑的问题。

程序越大，bug越多，相信永远都不会出现所谓的“完美程序”。随着软件规模原来越大，花再多的时间测试，也不能保障一个应用系统没有出现故障的可能。对于某些关键部位，一旦就问题出现，损失可能是不可接受的。那么在这些部位，最好的解决办法就是备份。硬件系统设计中，备份是很普遍的。软件系统承担起越来越多的工作后，也必然要采取这个方案。对同一功能，按不同的思路写两套实现代码。系统平时只用其中一份，一旦出现异常，系统就把另一份调出来使用。

生物的基因都是成对的，这不仅是为了繁衍后代，更是为了备份。如果某一条基因出现的缺损，另一条上的对应部位可以立即接替相应的功能，保证整个生物体的正常运作。


