---
title: "面向对象与数据流驱动的结合"
date: "2008-05-22"
tags: 
  - "我和labview"
---

    LabVIEW 是[数据流驱动的编程语言](http://ruanqizhen.spaces.live.com/blog/cns!5852D4F797C53FB6!2186.entry)：数据在数据线上流动，每个节点通过输入端的连线接收到数据，对其进行处理，再把结果传给输出端连线。  
    为了符合数据流的概念，多数情况下 LabVIEW 函数（或子VI）使用的传参方式是[值传递](http://ruanqizhen.spaces.live.com/blog/cns!5852D4F797C53FB6!2224.entry)：就仿佛是整个数据在连线上流动，遇到一个节点，便一股脑都传到节点中去。必要时，譬如数据线分叉的时候，数据便生成一个副本，这样就有了两份同样的数据，沿着不同的分支继续传递。  
    也有例外的情况，比如使用 refnum 这种数据类型的时候。真正有意义的数据是存放在内存的某个地方不动的，而在节点间流动的只是一个指向这片数据的引用。这种传引用的方式破坏了数据流的概念，只在不得已的情况下才可使用（比如在多线程中对同一块数据进行操作），否则还是应当尽可能遵循 LabVIEW 一贯的值传递方式。

    为了与用户熟知的数据流方式兼容（风格不一致，必然造成程序的极大混乱），LabVIEW 中的对象也是按照值传递的方式在节点间流动的。这点和其它语言有所差别，文本编程语言中传递对象时，基本都使用传引用的方式。  
    实际上，这两种传参方式各有特色，LabVIEW 别具一格的选择了值传递方式，是因为，在 LabVIEW 中，值传递的优势更大一些。

    传引用的优点在于效率高，一个对象的数据量往往都比较大，值传递免不了要生成一些副本给被传递的数据，这类开销是相当大的。而一个引用类型的数据一般只需要占用4或8个字节，传递它们的开销远小于直接传递数据。  
    在多线程程序中，传引用意味着不同的线程可以访问同一块数据。在不同的线程中同时对同一数据进行读写是很危险的，它可能会产生不可预期的结果。所以，在多线程程序中常常使用临界区、信号量等方法来防止竞争状态的出现。这对于 C++ 或其他文本语言的程序员不是一个太大的问题，编写多线程程序的人员多少已经对可能出现的竞争状态有所了解。并且他们清楚地知道自己在编写多线程程序，会格外留意并采取相应措施防止错误出现。

    而 LabVIEW 的使用者中，相当一部分人是非计算机专业的。为了帮助这些非计算机专业编程者利用多线程的优势，LabVIEW  采用了[自动多线程的机制](http://ruanqizhen.spaces.live.com/blog/cns!5852D4F797C53FB6!1494.entry)。LabVIEW 中，编程者并不需要告诉程序去开辟新线程；任何两段逻辑上没有先后顺序的代码，都有可能被自动的放到两个线程里去同时执行。  
    在这种情况下，传引用是非常危险的，编程者可能根本没意识不到程序有多个线程，因而无意中写下存在竞争状态的代码。  
    只有值传递才可以解决这个问题。值传递意味着数据每到一个分叉处，就变成相等但互相独立的两份数据。每个可能同时运行的数据线上的数据都是相互独立的，程序永远不会试图去同时访问同一个数据。这样就避免了无意识下造成的竞争状态。如果程序中的确需要在不同线程里处理同一对象，编程者可以在明确程序风险的前提下使用 LabVIEW 中的传引用机制，并做好多线程安全防护。

    那么，类的实例作为值传递的数据，到底都包含哪些内容呢？这个数据你可以把它看成是一个簇。这个簇中可能又包含一下多个簇：  
    1. 一个簇包含所有类的属性；  
    2. 一个簇包含它父类的所有属性；  
    3. 一个簇包含它父类的父类的所有属性；  
    4. 一个簇包含它父类的父类的父类的……  
    ……  
    除了这些属性数据，类的实例还包含有自身类别的信息，比如自己属于哪个类，什么版本等。这样，一个实例即便是按照它的某个祖先类来传递，也同样可以在需要的时候调用属于自己本身类的方法。

[《我和LabVIEW》目录](http://ruanqizhen.spaces.live.com/blog/cns!5852D4F797C53FB6!1073.entry)
